@page "{id:int?}"
@model WindowPainter.Pages.CanvasModel
@{
    Layout = "_Layout";
    ViewBag.Title = Model.Painting.Title;
}
<style>
    html { overflow: hidden; }
    #canvas {
        position: absolute;
        box-shadow: 0 0 10px 0 rgba(0,0,0,0.5);
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -o-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: pixelated;
        image-rendering: optimize-contrast;
        -ms-interpolation-mode: nearest-neighbor;
    }
    .shadow {
        position: absolute;
        background-color: rgba(128, 128, 128, 0.75);
        border: 3px solid black;
        box-sizing: content-box;
    }
</style>
<nav id="nav" class="navbar is-primary" role="navigation" aria-label="main navigation">
    <div class="navbar-menu is-active">
        <div class="navbar-start">
            <div class="navbar-item">
                <a class="button is-primary is-small is-inverted">
                    <span class="icon is-small">
                        <i class="fa fa-save"></i>
                    </span>
                    <span id="save">Save</span>
                </a>
            </div>
            <div class="navbar-item">
                <a class="button is-primary is-small is-inverted">
                    <span class="icon is-small">
                        <i class="fa fa-paint-brush"></i>
                    </span>
                    <span id="new-brush">New brush</span>
                </a>
            </div>
            <div class="navbar-item">
                <a class="button is-danger is-small is-inverted">
                    <span class="icon is-small">
                        <i class="fa fa-times"></i>
                    </span>
                    <span id="close-brushes">Close all brushes</span>
                </a>
            </div>
        </div>
        <div class="navbar-end">
            <div class="navbar-item">
                <a class="button is-primary is-small is-inverted">
                    <span class="icon is-small">
                        <i class="fa fa-bullseye"></i>
                    </span>
                    <span id="calibrate">Calibrate brush</span>
                </a>
            </div>
        </div>
    </div>
</nav>
<div class="modal" id="calibration-modal">
    <div class="modal-background"></div>
    <div class="modal-card">
        <div class="modal-card-head">
            <h2 class="subtitle">Calibration</h2>
        </div>
        <div class="modal-card-body">
            <div class="content">
                <div style="position: relative; width: 240px; height: 240px; margin: 0 auto;">
                    <div style="position: absolute;top: 20px; left: 20px; width: 200px; height: 200px; background-color: #ddd" id="offset-target"></div>
                    <div style="position: absolute;top: 40px; left: 0; width: 240px; height: 160px; border-top: 2px solid black; border-bottom: 2px solid black"></div>
                    <div style="position: absolute;top: 0; left: 40px; width: 160px; height: 240px; border-left: 2px solid black; border-right: 2px solid black"></div>
                </div>
                <p>Align the indicators in the popup with those on this page and click <strong>Done</strong> in the popup. You can use the arrow keys to move the popup small amounts.</p>
            </div>
        </div>
        <div class="modal-card-foot" style="justify-content: flex-end;">
            <button id="cancel-calibration" class="button">Cancel</button>
        </div>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
(() => {
    var brushes = [];
    function openBrush() {
        var brush = {};
        var id = brushes.push(brush) - 1;
        brush.win = window.open("/Brush?" + id,
            "_blank",
            "top=" + (window.screenY + 100) +
            ",left=" + (window.screenX + 100) +
            ",width=" + (200 * devicePixelRatio) +
            ",height=" + (200 * devicePixelRatio));;
        brush.shadow = document.createElement("div");
        brush.shadow.classList.add("shadow");
        document.body.appendChild(brush.shadow);
        brush.win.onbeforeunload = () => {
            brush.shadow.parentNode.removeChild(brush.shadow);
            delete brush.win;
            delete brush.shadow;
        }
    }
    function closeAllBrushes() {
        while (brushes.length) {
            var brush = brushes.pop();
            if(brush.win) {
                brush.win.close();
            }
        }
    }
    document.getElementById("new-brush").addEventListener("click", openBrush, false);
    document.getElementById("close-brushes").addEventListener("click", closeAllBrushes, false);

    var offsetX = +localStorage.offsetX || 0;
    var offsetY = +localStorage.offsetY || 0;
    var offsetTarget = document.getElementById("offset-target");
    window.applyOffsets = function (winX, winY) {
        var offsetRect = offsetTarget.getBoundingClientRect();
        offsetX = (winX - screenX) / devicePixelRatio - offsetRect.left;
        offsetY = (winY - screenY) / devicePixelRatio - offsetRect.top;
        localStorage.offsetX = offsetX;
        localStorage.offsetY = offsetY;
    }
    var modal = document.getElementById("calibration-modal");
    document.getElementById("calibrate").addEventListener("click", _ => {
        modal.classList.add("is-active");
        var calibrator = window.open("/Calibrator",
            "_blank",
            "top=" + (window.screenY + 100) +
            ",left=" + (window.screenX + 100) +
            ",width=" + (200 * devicePixelRatio) +
            ",height=" + (200 * devicePixelRatio));
        calibrator.onbeforeunload = () => {
            modal.classList.remove("is-active");
        }
    }, false);
    document.getElementById("cancel-calibration").addEventListener("click", _ => modal.classList.remove("is-active"), false);

    var colors = {
        black: 0xff000000,
        white: 0xffffffff,
        red: 0xff0000ff
    }

    var nav = document.getElementById("nav");
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var image;
    var pixels;

    function save() {
        var req = new XMLHttpRequest();
        req.open("PUT", "/api/paintings/@Model.Painting.Id", true);
        req.setRequestHeader("Content-Type", "application/octet-stream");
        req.send(image.data.buffer);
    }
    document.getElementById("save").addEventListener("click", save, false);

    function draw() {
        if(image != null) {
            ctx.putImageData(image, 0, 0);
        }
    }

    function resize(){
        var availableHeight = innerHeight - nav.clientHeight;
        var size = Math.min(innerWidth, availableHeight) - 20;
        canvas.style.top = nav.clientHeight + (availableHeight - size >> 1) + "px";
        canvas.style.left = (innerWidth - size >> 1) + "px";
        canvas.style.width = size + "px";
        canvas.style.height = size + "px";
        canvas.width = 100;
        canvas.height = 100;

        draw();
    }
    window.addEventListener("resize", () => {
        window.requestAnimationFrame(resize);
    });
    resize();

    fetch("/api/paintings/@Model.Painting.Id")
        .then(res => res.arrayBuffer())
        .then(arr => {
            image = new ImageData(new Uint8ClampedArray(arr), 100, 100);
            pixels = new Uint32Array(image.data.buffer);
            draw();
        })
        .then(draw);

    window.paint = function (winX, winY, winWidth, winHeight, color, id) {
        var left = (winX - screenX) / devicePixelRatio - offsetX;
        var top = (winY - screenY) / devicePixelRatio - offsetY;
        var width = winWidth;
        var height = winHeight;
        var shadow = brushes[id].shadow;
        if(shadow != null) {
            shadow.style.left = left - 3 + "px";
            shadow.style.top = top - 3 + "px";
            shadow.style.width = width + "px";
            shadow.style.height = height + "px";
        }

        var canvasRect = canvas.getBoundingClientRect();
        var minY = 100 * (top - canvasRect.top) / canvasRect.height >> 0;
        var minX = 100 * (left - canvasRect.left) / canvasRect.width >> 0;
        var maxY = minY + 100 * height / canvasRect.height >> 0;
        var maxX = minX + 100 * width / canvasRect.width >> 0;
        if (maxX >= 0 && minY < 100 && maxY >= 0 && minX < 100) {
            var mMinY = Math.max(0, minY);
            var mMinX = Math.max(0, minX);
            var mMaxY = Math.min(99, maxY);
            var mMaxX = Math.min(99, maxX);
            var value = colors[color];
            for (var y = mMinY; y <= mMaxY; y++) {
                for (var x = mMinX; x <= mMaxX; x++) {
                    pixels[x + 100 * y] = value;
                }
            }

            draw();
        }
    }
    })();
</script>